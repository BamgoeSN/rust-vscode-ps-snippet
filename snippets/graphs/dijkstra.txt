fn dijkstra<T: Copy + From<u8> + std::ops::Add<Output = T> + Eq + Ord>(
    graph: &Graph<T>,
    src: usize,
) -> Vec<Option<T>> {
    use std::{cmp::Reverse, collections::BinaryHeap};
    let mut dist: Vec<Option<T>> = vec![None; graph.n];
    let mut heap: BinaryHeap<(Reverse<T>, usize)> = BinaryHeap::new();
    heap.push((Reverse(0.into()), src));

    while let Some((Reverse(curr_cost), curr)) = heap.pop() {
        if dist[curr].map_or(false, |x| x < curr_cost) {
            continue;
        }
        dist[curr] = Some(curr_cost);

        for (next, &weight) in graph.neighbor(curr) {
            let next_cost = curr_cost + weight;
            if dist[next].map_or(true, |x| x > next_cost) {
                dist[next] = Some(next_cost);
                heap.push((Reverse(next_cost), next));
            }
        }
    }

    dist
}