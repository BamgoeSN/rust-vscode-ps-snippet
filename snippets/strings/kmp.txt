struct KMPNeedle<'n, T: PartialEq> {
    p: &'n [T],
    c: Vec<usize>,
}

impl<'n, T: PartialEq> KMPNeedle<'n, T> {
    fn new(p: &'n [T]) -> Self {
        let mut c: Vec<usize> = vec![0; p.len() + 1];

        let mut l = 0;
        for (r, v) in p.iter().enumerate().skip(1) {
            while l > 0 && p[l] != *v {
                l = c[l];
            }
            if p[l] == *v {
                c[r + 1] = l + 1;
                l += 1;
            }
        }

        Self { p, c }
    }
}

struct KMPMatcher<'h, 'n: 'h, 'a: 'n, T: PartialEq> {
    needle: &'a KMPNeedle<'n, T>,
    haystack: &'h [T],
    hp: usize,
    np: usize,
}

impl<'h, 'n: 'h, 'a: 'n, T: PartialEq> KMPMatcher<'h, 'n, 'a, T> {
    fn new(needle: &'a KMPNeedle<'n, T>, haystack: &'h [T]) -> Self {
        Self {
            needle,
            haystack,
            hp: 0,
            np: 0,
        }
    }
}

impl<'h, 'n: 'h, 'a: 'n, T: PartialEq> Iterator for KMPMatcher<'h, 'n, 'a, T> {
    type Item = usize;

    fn next(&mut self) -> Option<Self::Item> {
        while self.hp < self.haystack.len() {
            while self.np > 0 && self.haystack[self.hp] != self.needle.p[self.np] {
                self.np = self.needle.c[self.np];
            }
            if self.haystack[self.hp] == self.needle.p[self.np] {
                if self.np == self.needle.p.len() - 1 {
                    self.np = self.needle.c[self.np + 1];
                    self.hp += 1;
                    return Some(self.hp - self.needle.p.len());
                } else {
                    self.np += 1;
                }
            }
            self.hp += 1;
        }
        None
    }
}
